این «پرامپت سوپر‌دی‌تیلد» رو عیناً بده به Replit AI تا مشکل «لینک به دامین نمونه/خالی» برطرف بشه. راه‌حل پایدار اینه که فقط **یک سرویس** روی **`0.0.0.0:$PORT`** گوش بده (Uvicorn/FastAPI) و فرانت هم با **`vite build --watch`** همیشه تازه بمونه. هیچ تغییری در `vite.config.ts` انجام نمی‌دهیم.

---

# 🔧 Replit AI — Reset & Fix: Single-Port Dev (FastAPI serves built React)

**Do NOT edit `vite.config.ts`.**
Frontend must call API with **relative base** (`/api/v1`) — نه `http://localhost...`.

## GOAL

* فقط **Uvicorn/FastAPI** روی `0.0.0.0:$PORT` گوش بده تا Replit URL درست بده.
* React با `vite build --watch` باندل شه و از مسیر `dist/` توسط FastAPI سرو بشه.
* `/api/v1/*` → API، سایر مسیرها → `dist/index.html` (SPA fallback).
* اگر تلگرام بات داری، همزمان اجرا بشه ولی **پورت عمومی نگیره**.

---

## 1) Backend: سرو `dist` + SPA fallback + health

**`app/main.py`** را بساز/جایگزین کن:

```py
import os
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from starlette.responses import FileResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Dev: CORS باز (در پروداکشن محدودش کن)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/api/v1/health")
def health():
    return {"ok": True}

# سرو فایل‌های باندل‌شده
if os.path.isdir("dist"):
    if os.path.isdir("dist/assets"):
        app.mount("/assets", StaticFiles(directory="dist/assets"), name="assets")
    app.mount("/_app", StaticFiles(directory="dist"), name="dist_root")

# SPA fallback: هرچی غیر از /api → index.html
@app.get("/{full_path:path}")
def spa(full_path: str):
    index_path = os.path.join("dist", "index.html")
    if os.path.exists(index_path):
        return FileResponse(index_path)
    return JSONResponse({"detail": "Frontend not built yet. Run: npm run build"}, status_code=503)
```

---

## 2) Frontend Runtime Config (بدون پراکسی)

**`public/app-config.json`** را بساز:

```json
{ "API_BASE": "/api/v1" }
```

اگر loader نداری، این دو فایل را اضافه کن:

**`src/lib/runtimeConfig.ts`**

```ts
export type AppCfg = { API_BASE: string };
export async function loadRuntimeConfig(): Promise<AppCfg> {
  try {
    const r = await fetch('/app-config.json', { cache: 'no-store' });
    if (r.ok) return r.json();
  } catch {}
  return { API_BASE: '/api/v1' };
}
```

**`src/lib/api.ts`**

```ts
let cfg = { API_BASE: '/api/v1' };
export function setRuntimeCfg(c: { API_BASE: string }) { cfg = c; }

type FetchOpts = RequestInit & { auth?: boolean };
export async function api<T>(path: string, opts: FetchOpts = {}): Promise<T> {
  const url = `${cfg.API_BASE}${path}`;
  const headers: Record<string,string> = { 'Content-Type': 'application/json' };
  if (opts.auth) {
    const t = localStorage.getItem('token');
    if (t) headers.Authorization = `Bearer ${t}`;
  }
  const res = await fetch(url, { ...opts, headers: { ...headers, ...(opts.headers||{}) } });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json() as Promise<T>;
}
```

و در **`src/main.tsx`** (بوت):

```ts
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { loadRuntimeConfig } from './lib/runtimeConfig';
import { setRuntimeCfg } from './lib/api';

loadRuntimeConfig().then(cfg => {
  setRuntimeCfg(cfg);
  ReactDOM.createRoot(document.getElementById('root')!).render(<App />);
});
```

> هر جا آدرس ثابت مثل `http://localhost:8000/api/v1` استفاده شده، حذف و فقط از helper `api('/...')` استفاده شود.

---

## 3) Scripts: تک‌پورت Dev (بدون HMR، ولی زنده)

**`package.json`** را این‌طور تنظیم کن:

```json
{
  "scripts": {
    "dev": "concurrently -k \"vite build --watch\" \"uvicorn app.main:app --host 0.0.0.0 --port $PORT\"",
    "build": "vite build",
    "preview": "vite preview --host --port $PORT"
  },
  "devDependencies": {
    "concurrently": "^9.0.0"
  }
}
```

* **Run** در Replit = `npm run dev`
* لاگ‌ها باید نشان بدهند:

  * `vite ... building for production... (watching)`
  * `Uvicorn running on http://0.0.0.0:$PORT`

> اگر **بات تلگرام** داری و پورت نمی‌گیرد، می‌توانی اضافه کنی:

```json
"dev": "concurrently -k \"vite build --watch\" \"uvicorn app.main:app --host 0.0.0.0 --port $PORT\" \"python -m bot.telegram_importer\""
```

---

## 4) Cleanup و تنظیمات Replit

* اگر قبلاً چند پروسه داشتی (Vite dev روی پورت خودش، پروکسی، …) همه را از scripts حذف کن تا **فقط دو تا** اجرا شوند: `vite build --watch` و `uvicorn`.
* **هیچ سرویس دیگری** نباید روی `$PORT` بجز Uvicorn گوش بدهد.
* اگر Replit Deployment استفاده می‌کنی: Entry باید همین `npm run dev` یا معادل Uvicorn باشد که روی `$PORT` گوش می‌دهد.

---

## 5) Acceptance (باید پاس شوند)

* باز کردن URL Replit → **صفحه فرانت** از `dist` لود می‌شود.
* رفتن به `…/api/v1/health` → `{"ok": true}` می‌گیری.
* تمام درخواست‌های کلاینت به **مسیر نسبی** `/api/v1/...` می‌خورند (نه localhost، نه پورت دیگر).
* رفرش مسیرهای داخلی (مثل `/products/123`) → SPA fallback کار می‌کند.
* هیچ تغییری به `vite.config.ts` اعمال نشده.

---

## 6) اگر بعداً HMR خواستی (اختیاری)

برای HMR بدون دست‌زدن به `vite.config.ts`، یک **Express dev-proxy** روی `$PORT` بگذار که `/api` را به `127.0.0.1:8000` و بقیه مسیرها + WebSocket را به `127.0.0.1:5173` پاس بدهد. (الان لازم نیست؛ مدل تک‌پورت پایدارتر است و مشکل «دامنه نمونه» را کامل حل می‌کند.)

---

**یادآوری طلایی:** هر بار دیدی Replit لینک را به دامین خالی می‌برد یعنی هیچ‌کس روی `$PORT` گوش نمی‌دهد. با این مدل، همیشه Uvicorn روی `$PORT` روشن است و مشکل برطرف می‌شود.
