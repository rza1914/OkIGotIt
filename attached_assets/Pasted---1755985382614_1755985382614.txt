این دقیقاً همون الگوییه که وقتی «کلیک روی دکمه سبد» داخل یه بخشِ قابل‌کلیک (مثلاً لینک “محصولات” یا کارت محصول) باشه رخ می‌ده: اول ناوبری اجرا می‌شه، بعد handler سبد. راه‌حل قطعی: جلوی ناوبری پیش‌فرض + حباب‌دادن رو بگیر و مطمئن شو دکمه داخل هیچ `<Link>`/`<a>` یا کانتینری که onClick ناوبری داره نیست.

### 1) دکمه سبد در هدر — نسخه ضد‌ناوبری

جای دکمه‌ی فعلی سبد، همینو بذار:

```tsx
import { useCart } from "@/contexts/CartContext";

export function HeaderCartButton() {
  const { openCart, toggleCart } = useCart();

  return (
    <button
      type="button"
      aria-label="سبد خرید"
      className="btn-secondary relative"
      // جلوگیری «قبل از» کلیک برای موبایل/سافاری
      onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); }}
      onTouchStart={(e) => { e.preventDefault(); e.stopPropagation(); }}
      // کلیک اصلی
      onClick={(e) => {
        e.preventDefault();
        e.stopPropagation();      // جلوی رفتن به /products یا هر مسیر دیگه
        toggleCart();             // یا openCart()
      }}
    >
      🛒 سبد
    </button>
  );
}
```

**خیلی مهم:** این دکمه نباید داخل هیچ `<Link>` یا `<a>` یا `<li onClick={()=>navigate('/products')}>` باشه. اگر منو آیتم‌ها رو با `li` کلیکی ساختی، دکمه سبد رو بیرون اون `li` بگذار یا روی دکمه علاوه بر کد بالا، از `onClickCapture={(e)=>e.stopPropagation()}` هم استفاده کن.

---

### 2) کارت محصول + دکمه «افزودن به سبد»

اگر کل کارت قابل کلیک/لینک به جزئیات محصوله، روی دکمهٔ «افزودن» اینو بذار:

```tsx
<button
  type="button"
  className="btn-primary"
  onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); }}
  onTouchStart={(e) => { e.preventDefault(); e.stopPropagation(); }}
  onClick={(e) => {
    e.preventDefault();
    e.stopPropagation();   // نذار onClick کارت/Link اجرا شه
    addItem({ id, name, price, image_url });
    openCart();
  }}
>
  افزودن به سبد
</button>
```

و روی **خود کارت**‌ که ناوبری می‌ده:

```tsx
<div
  role="button"
  tabIndex={0}
  onClick={() => navigate(`/product/${id}`)}
  onKeyDown={(e) => { if (e.key === 'Enter') navigate(`/product/${id}`); }}
>
  {/* محتوا + دکمه افزودن (با stopPropagation بالا) */}
</div>
```

---

### 3) اگر دکمه داخل آیتم منو قرار گرفته

بعضی‌ها منو را اینطوری می‌سازند:

```tsx
<li onClick={()=>navigate('/products')}>
  محصولات
  <HeaderCartButton />   // ❌ اشتباه: دکمه داخل آیتمی که کلیک = ناوبری
</li>
```

حلش:

* دکمه سبد را **از آن li** جدا کن (در یک کانتینر Actions جدا).
* یا روی دکمه علاوه بر کد بالا، `onClickCapture={(e)=>e.stopPropagation()}` بگذار.
* بهتر: ساختار هدر را جدا کن: راست (لوگو+جستجو) | وسط (NavLinks) | چپ (UserMenu + CartButton).

---

### 4) تست ۳۰‌ثانیه‌ای

* DevTools → Elements: روی دکمهٔ سبد راست‌کلیک Inspect کن و در کنسول بزن:

  ```js
  $0.closest('a, [data-link], [role=link]')
  ```

  باید `null` برگرده. اگر چیزی برگشت، یعنی دکمه داخل یک لینک/ناوبریه؛ جابه‌جاش کن.
* اگر ناوبری هنوز رخ می‌ده، موقتاً handler کارت/منو را غیرفعال کن تا مطمئن بشی مقصر همان‌هاست.

---

### 5) یک نکتهٔ مکمل برای React Router

تمام لینک‌های منو باید `NavLink/Link` باشند و دکمه‌ها **button**. هیچ `<a href="#">` یا `<a href="/products">` خام نذار. برای اسکرول به سکشن هم `scrollIntoView` به‌جای `href="#..."`.

---

با همین دوتا تغییر (preventDefault + stopPropagation در دکمه‌ها و جداکردن‌شون از لینک/کانتینرهای کلیکی)، مشکل «اول می‌ره /products بعد سایدبار باز می‌شه» کامل از بین می‌ره.
