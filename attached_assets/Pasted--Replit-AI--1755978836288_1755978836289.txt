Ø§ÛŒÙ† Â«Ù¾Ø±Ø§Ù…Ù¾Øª Ø³ÙˆÙ¾Ø±â€ŒØ¯ÛŒâ€ŒØªÛŒÙ„Ø¯Â» Ø±Ùˆ Ø¹ÛŒÙ†Ø§Ù‹ Ø¨Ø¯Ù‡ Ø¨Ù‡ Replit AI ØªØ§ Ù…Ø´Ú©Ù„ Â«Ø¯Ø§Ù…Ù†Ù‡â€ŒÛŒ Ø®Ø§Ù„ÛŒ/Ø³Ø±ÙˆØ±Ù‡Ø§ Ø®Ø§Ù…ÙˆØ´Â» Ø­Ù„ Ø¨Ø´Ù‡. Ø±Ø§Ù‡â€ŒØ­Ù„ Ù¾Ø§ÛŒØ¯Ø§Ø±: **ÛŒÚ©â€ŒÙ¾ÙˆØ±Øª**. ÛŒØ¹Ù†ÛŒ ÙÙ‚Ø· **FastAPI Ø±ÙˆÛŒ `$PORT`** Ø³Ø±Ùˆ Ù…ÛŒâ€ŒÚ©Ù†Ù‡ Ùˆ React Ø¨Ø§ `vite build --watch` Ø®Ø±ÙˆØ¬ÛŒ Ø±Ùˆ Ù‡Ù…ÛŒØ´Ù‡ ØªØ§Ø²Ù‡ Ù†Ú¯Ù‡ Ù…ÛŒâ€ŒØ¯Ø§Ø±Ù‡. (Ù‡ÛŒÚ† ØªØºÛŒÛŒØ±ÛŒ Ø¯Ø± `vite.config.ts` Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ù‡.)

---

# ğŸ”§ Replit AI â€” Fix Empty Domain: One-Port Dev (FastAPI serves built React)

**Absolute constraints:**

* â—ï¸**Do NOT edit `vite.config.ts`**. Assume itâ€™s correct.
* App must listen on **`0.0.0.0:$PORT`** so Replit shows the right URL.
* Frontend must call API with a **relative** base (`/api/v1`), not `http://localhost:8000`.

## Goal

Run the project in Replit so that:

* Only **one** HTTP server listens on `$PORT`: **Uvicorn (FastAPI)**.
* React is built continuously (`vite build --watch`) and its `dist` is served by FastAPI.
* Visiting the Replit URL loads the **frontend** and `/api/v1/*` hits the **backend**.
* No proxy, no vite host allowlist issues, no `vite.config.ts` edits.

---

## 1) Backend: serve `dist` + SPA fallback + health

Create/overwrite `app/main.py` with:

```py
import os
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from starlette.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Dev: open CORS (limit in prod)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/api/v1/health")
def health():
    return {"ok": True}

# Serve built frontend assets
if os.path.isdir("dist"):
    app.mount("/assets", StaticFiles(directory="dist/assets"), name="assets")
    # Optional: other root files (manifest, icons)
    app.mount("/_app", StaticFiles(directory="dist"), name="dist_root")

# SPA fallback: everything not /api -> index.html
@app.get("/{full_path:path}")
def spa(full_path: str):
    index_path = os.path.join("dist", "index.html")
    if os.path.exists(index_path):
        return FileResponse(index_path)
    return {"detail": "Frontend not built yet. Run: npm run build"}
```

> Ù†Ú©ØªÙ‡: Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ `/api/v1/...` Ø¨Ø±Ø§ÛŒ API Ù‡Ø³ØªÙ†Ø› Ø¨Ù‚ÛŒÙ‡ Ù…Ø³ÛŒØ±Ù‡Ø§ `index.html` Ø±Ùˆ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯ÙˆÙ†Ù† ØªØ§ SPA Ú©Ø§Ø± Ú©Ù†Ù‡.

---

## 2) Frontend runtime API base (no proxy)

Create/ensure `public/app-config.json` exists with:

```json
{ "API_BASE": "/api/v1" }
```

Use a small runtime loader (if not already present):

`src/lib/runtimeConfig.ts`:

```ts
export type AppCfg = { API_BASE: string };
export async function loadRuntimeConfig(): Promise<AppCfg> {
  try {
    const r = await fetch('/app-config.json', { cache: 'no-store' });
    if (r.ok) return r.json();
  } catch {}
  return { API_BASE: '/api/v1' };
}
```

`src/lib/api.ts`:

```ts
let cfg: { API_BASE: string } = { API_BASE: '/api/v1' };
export function setRuntimeCfg(c: { API_BASE: string }) { cfg = c; }

type FetchOpts = RequestInit & { auth?: boolean };
export async function api<T>(path: string, opts: FetchOpts = {}): Promise<T> {
  const url = `${cfg.API_BASE}${path}`;
  const headers: Record<string, string> = { 'Content-Type': 'application/json' };
  if (opts.auth) {
    const t = localStorage.getItem('token');
    if (t) headers.Authorization = `Bearer ${t}`;
  }
  const res = await fetch(url, { ...opts, headers: { ...headers, ...(opts.headers||{}) } });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json() as Promise<T>;
}
```

`src/main.tsx` (bootstrap):

```ts
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { loadRuntimeConfig } from './lib/runtimeConfig';
import { setRuntimeCfg } from './lib/api';

loadRuntimeConfig().then((c) => {
  setRuntimeCfg(c);
  ReactDOM.createRoot(document.getElementById('root')!).render(<App />);
});
```

> Ø§Ú¯Ø± Ø¬Ø§ÛŒÛŒ Ø¯Ø± Ú©Ø¯ Ø¢Ø¯Ø±Ø³ Ø«Ø§Ø¨Øª Ù…Ø«Ù„ `http://localhost:8000/api/v1` Ø¯Ø§Ø±ÛŒØŒ Ø­Ø°ÙØ´ Ú©Ù†Ø› ÙÙ‚Ø· Ø§Ø² `api('/...')` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†.

---

## 3) Scripts: single-port dev (no HMR, but live build)

Update `package.json` scripts to:

```json
{
  "scripts": {
    "dev": "concurrently -k \"vite build --watch\" \"uvicorn app.main:app --host 0.0.0.0 --port $PORT\"",
    "build": "vite build",
    "preview": "vite preview --host --port $PORT"
  },
  "devDependencies": {
    "concurrently": "^9.0.0"
  }
}
```

* Replit **Run** command = `npm run dev`
* Log should show:

  * `vite ... building for production... (watching)`
  * `Uvicorn running on http://0.0.0.0:$PORT`

Optional: if you have a Telegram importer bot, you can also run it alongside (it doesnâ€™t bind a public port):

```json
"dev": "concurrently -k \"vite build --watch\" \"uvicorn app.main:app --host 0.0.0.0 --port $PORT\" \"python -m bot.telegram_importer\""
```

---

## 4) Acceptance checks

* Open the Replit URL â†’ **frontend loads** (from `dist`).
* Go to `/api/v1/health` â†’ returns `{"ok": true}`.
* All client API calls are to **relative** paths (e.g., `GET /api/v1/products`) â€” no CORS, no localhost.
* Refreshing deep routes (e.g., `/products/123`) works (served by SPA fallback).
* No need to touch `vite.config.ts`.

---

## 5) If you still need live HMR later (optional)

Keep this setup for stability. If HMR becomes necessary, add an **Express dev proxy** on `$PORT` that forwards `/api` to `127.0.0.1:8000` and all other paths + WebSocket to `127.0.0.1:5173`. This avoids Viteâ€™s allowedHosts without editing `vite.config.ts`. (Not required now.)

---

**Done.** Ø¨Ø§ Ø§ÛŒÙ† Ù…Ø¯Ù„ Â«ØªÚ©â€ŒÙ¾ÙˆØ±ØªÂ»ØŒ Replit Ù‡Ù…ÛŒØ´Ù‡ Ø¨Ù‡ ÛŒÚ© Ø³Ø±ÙˆØ± Ø²Ù†Ø¯Ù‡ ÙˆØµÙ„ Ù…ÛŒâ€ŒØ´Ù‡ Ùˆ Ù…Ø´Ú©Ù„ Â«Ø¯Ø§Ù…Ù†Ù‡â€ŒÛŒ Ø®Ø§Ù„ÛŒ/Ø³Ø±ÙˆØ±Ù‡Ø§ Ø®Ø§Ù…ÙˆØ´Â» Ø­Ù„ Ù…ÛŒâ€ŒØ´Ù‡.
