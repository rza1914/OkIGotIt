این «پرامپت سوپر‌دی‌تیلد» رو عیناً بده به Replit AI تا مشکل «دامنه‌ی خالی/سرورها خاموش» حل بشه. راه‌حل پایدار: **یک‌پورت**. یعنی فقط **FastAPI روی `$PORT`** سرو می‌کنه و React با `vite build --watch` خروجی رو همیشه تازه نگه می‌داره. (هیچ تغییری در `vite.config.ts` انجام نشه.)

---

# 🔧 Replit AI — Fix Empty Domain: One-Port Dev (FastAPI serves built React)

**Absolute constraints:**

* ❗️**Do NOT edit `vite.config.ts`**. Assume it’s correct.
* App must listen on **`0.0.0.0:$PORT`** so Replit shows the right URL.
* Frontend must call API with a **relative** base (`/api/v1`), not `http://localhost:8000`.

## Goal

Run the project in Replit so that:

* Only **one** HTTP server listens on `$PORT`: **Uvicorn (FastAPI)**.
* React is built continuously (`vite build --watch`) and its `dist` is served by FastAPI.
* Visiting the Replit URL loads the **frontend** and `/api/v1/*` hits the **backend**.
* No proxy, no vite host allowlist issues, no `vite.config.ts` edits.

---

## 1) Backend: serve `dist` + SPA fallback + health

Create/overwrite `app/main.py` with:

```py
import os
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from starlette.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Dev: open CORS (limit in prod)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/api/v1/health")
def health():
    return {"ok": True}

# Serve built frontend assets
if os.path.isdir("dist"):
    app.mount("/assets", StaticFiles(directory="dist/assets"), name="assets")
    # Optional: other root files (manifest, icons)
    app.mount("/_app", StaticFiles(directory="dist"), name="dist_root")

# SPA fallback: everything not /api -> index.html
@app.get("/{full_path:path}")
def spa(full_path: str):
    index_path = os.path.join("dist", "index.html")
    if os.path.exists(index_path):
        return FileResponse(index_path)
    return {"detail": "Frontend not built yet. Run: npm run build"}
```

> نکته: مسیرهای `/api/v1/...` برای API هستن؛ بقیه مسیرها `index.html` رو برمی‌گردونن تا SPA کار کنه.

---

## 2) Frontend runtime API base (no proxy)

Create/ensure `public/app-config.json` exists with:

```json
{ "API_BASE": "/api/v1" }
```

Use a small runtime loader (if not already present):

`src/lib/runtimeConfig.ts`:

```ts
export type AppCfg = { API_BASE: string };
export async function loadRuntimeConfig(): Promise<AppCfg> {
  try {
    const r = await fetch('/app-config.json', { cache: 'no-store' });
    if (r.ok) return r.json();
  } catch {}
  return { API_BASE: '/api/v1' };
}
```

`src/lib/api.ts`:

```ts
let cfg: { API_BASE: string } = { API_BASE: '/api/v1' };
export function setRuntimeCfg(c: { API_BASE: string }) { cfg = c; }

type FetchOpts = RequestInit & { auth?: boolean };
export async function api<T>(path: string, opts: FetchOpts = {}): Promise<T> {
  const url = `${cfg.API_BASE}${path}`;
  const headers: Record<string, string> = { 'Content-Type': 'application/json' };
  if (opts.auth) {
    const t = localStorage.getItem('token');
    if (t) headers.Authorization = `Bearer ${t}`;
  }
  const res = await fetch(url, { ...opts, headers: { ...headers, ...(opts.headers||{}) } });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json() as Promise<T>;
}
```

`src/main.tsx` (bootstrap):

```ts
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { loadRuntimeConfig } from './lib/runtimeConfig';
import { setRuntimeCfg } from './lib/api';

loadRuntimeConfig().then((c) => {
  setRuntimeCfg(c);
  ReactDOM.createRoot(document.getElementById('root')!).render(<App />);
});
```

> اگر جایی در کد آدرس ثابت مثل `http://localhost:8000/api/v1` داری، حذفش کن؛ فقط از `api('/...')` استفاده کن.

---

## 3) Scripts: single-port dev (no HMR, but live build)

Update `package.json` scripts to:

```json
{
  "scripts": {
    "dev": "concurrently -k \"vite build --watch\" \"uvicorn app.main:app --host 0.0.0.0 --port $PORT\"",
    "build": "vite build",
    "preview": "vite preview --host --port $PORT"
  },
  "devDependencies": {
    "concurrently": "^9.0.0"
  }
}
```

* Replit **Run** command = `npm run dev`
* Log should show:

  * `vite ... building for production... (watching)`
  * `Uvicorn running on http://0.0.0.0:$PORT`

Optional: if you have a Telegram importer bot, you can also run it alongside (it doesn’t bind a public port):

```json
"dev": "concurrently -k \"vite build --watch\" \"uvicorn app.main:app --host 0.0.0.0 --port $PORT\" \"python -m bot.telegram_importer\""
```

---

## 4) Acceptance checks

* Open the Replit URL → **frontend loads** (from `dist`).
* Go to `/api/v1/health` → returns `{"ok": true}`.
* All client API calls are to **relative** paths (e.g., `GET /api/v1/products`) — no CORS, no localhost.
* Refreshing deep routes (e.g., `/products/123`) works (served by SPA fallback).
* No need to touch `vite.config.ts`.

---

## 5) If you still need live HMR later (optional)

Keep this setup for stability. If HMR becomes necessary, add an **Express dev proxy** on `$PORT` that forwards `/api` to `127.0.0.1:8000` and all other paths + WebSocket to `127.0.0.1:5173`. This avoids Vite’s allowedHosts without editing `vite.config.ts`. (Not required now.)

---

**Done.** با این مدل «تک‌پورت»، Replit همیشه به یک سرور زنده وصل می‌شه و مشکل «دامنه‌ی خالی/سرورها خاموش» حل می‌شه.
